---
tags:
  - sorbonne
  - informatique
  - architecture-des-ordinateurs
  - td
semestre: 3
---
## Exercice 1
Deux sections :
1. `.data` -> contient les variables globales (dites statiques)
2. `.text` -> contient les données du programme

Le point d'entrée est la première instruction de `.text`

Se termine avec le syscall exit :
```asm
ori $2, $0, 10
syscall
```
## Exercice 2
### Arithmétique
Les opcodes finissant par `u` sont pour les unsigned
Les opcodes avec `i` indiquent qu'il utilisera des immédiats

On préfère utiliser les versions unsigned

Format R = tous ceux qui ne finissent pas par `i`
|> travaillent avec les registres
|> immédiat est sur 16 bits
`mult`, `multu`, `div`, `divu` n'ont pas de registre de destination, ils vont toujours dans `HI` et `LO`

Format I = tous ceux qui finissent par `i`
|> travaillent avec les registres et un immédiat

`addiu $12, $18, 15` -> `0b001001 10010 01100 0000 0000 0000 1111`
`addu $12, $18, $4` -> `0b001001 10010 00100 01100 000 000 00000`
### Logique
`sra` et `srav` sont des opcodes logiques même s'il y a arithmétique dans leur nom
|> ils étendent le signe

Les opcodes *ne* finissant *pas* par `v` sont l'équivalent des `i` en arithmétique
|> mais il n'y a que des format R
|> pas d'immédiat, mais des `sh` (shifts)

`sll $9, $8, 8` avec `0x0000000F` dans `$8` donne `0x00000F00`
`srl $9, $8, 28` avec `0xF0000000` dans `$8` donne `0x0000 000F`
`sra $9, $8, 28` avec `0xF0000000` dans `$8` donne `0xFFFF FFFF`
`andi $9, $8, 0x000F` avec `0x0000 0036` donne `0x000 0006`
|> immédiat est sur 8 bits en logique

Pour mettre `8` dans `$8`, on fait : `ori $8, $0, 0x0000` ou `andi $8, $0, 0xFFFF`
Pour copier `$10` dans `$8`, on fait : `or $8, $0, $10` ou `addu $8, $10, $0`
## Exercice 3
`ori $8, $0, 0x1234`

```asm
ori $8, $0, 0x1234
sll $8, $8, 16
ori $8, $8, 0x5678
```
on peut aussi faire
```asm
lui $8, 0x1234 # met 0x1234 dans les bits de poids forts
ori $8, $8, 0x5678
```

```asm
.data

.text
	ori $8, $0, 0x34
	ori $9, $0, 34
	addu $10, $8, $9
	
	ori $2, $0, 10
	syscall
```
