---
tags:
  - sorbonne
  - informatique
  - architecture-des-ordinateurs
  - td
semestre: 3
---
$127_d$ prend 7 bits
$32_d$ prend 6 bits (car le nombre max dans $n$ bits est $2^n-1$ !)

Un mot hexa de taille $n$ permet de coder $16^n$ valeurs, soit toutes les valeurs entières dans $[0;16^n-1]$

| Mot binaire de 8 bits | Décimal | Mot hexa de 8 bits |
| --------------------- | ------- | ------------------ |
| `0b0000 1010`         | 10      | `0x0A`             |
| `0b0000 0010`         | 2       | `0x02`             |
| `0b0001 0000`         | 16      | `0x10`             |
| `0b0011 1001`         | 57      | `0x3B`             |
| `0b1000 0001`         | 127     | `0x81`             |
| `0b0001 0111`         | 23      | `0x17`             |
| `0b0101 1011`         | 91      | `0x5B`             |
| `0b0010 1001`         | 41      | `0x29`             |
| `0b1010 1010`         | 170     | `0xAA`             |
$5B_h+17_h = 72_h$ -> 7 bits
$71_h+B5_h = 126_h$ -> 9 bits

`0x2B` + `0x95` = `0xC0` -> pas de dépassement en interprétation « entier naturel »
`0xC8` + `0x6D` = `0x35` -> dépassement en interprétation « entier naturel »
`0x8B57` + `0xA34F` = `0x2EA6` -> dépassement en interprétation « entier naturel »

`0b1001 0011` - `0b1010 0011` = `0b1111 0000` -> dépassement en interprétation « entier naturel »
`0b1100 1111` - `0b1011 0011` = `0b0001 1100` -> pas de dépassement en interprétation « entier naturel »

`M1 & M2` = `0b1000`
`M1 | M2` = `0b1101`
`~M1` = `0b0110`
`M1 ^ M2` = `0b0101`

`M3 & 0x0000 FF00`
`M3 ^ M3 = 0x0000 0000`
`M3 ^ 0x0000 00FF` -> permet d'inverser les bits 0 à 7 (i.e. les 8 premiers)

`M7` = `0b01010011`
`M7 << 1` = `0b10100110`
`M7 << 2`= `0b01001100`
`M7 >> 4`= `0b00000101`

`<<` réduit le nombre entier naturel et `>>` l'augmente !

| Base 16  | Signe | Base 2                  | Opposé base 2           | Opposé base 16 |
| -------- | ----- | ----------------------- | ----------------------- | -------------- |
| `0x0B24` | +     | `0b0000 1011 0010 0100` | `Ob0111 0100 1101 1100` | `0x74DC`       |
| `0xABCD` | -     | `0b1010 1011 1100 1101` | `0b0101 0100 0011 0011` | `0x5433`       |
| `0xFFFF` | -     | `0b1111 1111 1111 1111` | `Ob0000 0000 0000 0001` | `0x0001`       |
`0b01101001` + `0b10000000` = `0b11101001`
|> est valide pour des naturels (pas de retenu sortante)
|> est valide pour des relatifs (les deux dernières retenues sont identiques)

`0b0110` + `0b0100` est valide en naturel, mais pas en relatif

`127 - 128 = -1` -> pas de dépassement
`120 - (- 150) = 270 > 127` -> dépassement de capacité
`-64 + 127 + 1 = 64` -> pas de dépassement de capacité
|> on n'aurait pas pu réaliser `-64 + 128` directement car 128 ne rentre pas sur 8 bits
|> si on avait fait `opposer(64 - 128)`, on aurait pu le faire

`0xFF` sur 32 bits, c'est `0xFFFFFFFF`
|> sa valeur en décimal (relatif en complément à 2), c'est $-1_d$
|> si c'est un naturel, c'est plus du tout la même chose !
